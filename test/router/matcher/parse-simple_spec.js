// Generated by LiveScript 1.2.0
(function(){
  describe('crossroads parse', function(){
    var _prevTypecast;
    beforeEach(function(){
      var _prevTypecast;
      return _prevTypecast = crossroads.shouldTypecast;
    });
    afterEach(function(){
      crossroads.resetState();
      crossroads.removeAllRoutes();
      crossroads.routed.removeAll();
      crossroads.bypassed.removeAll();
      return crossroads.shouldTypecast = _prevTypecast;
    });
    return describe('parse', function(){
      var _prevTypecast;
      beforeEach(function(){
        var _prevTypecast;
        return _prevTypecast = crossroads.shouldTypecast;
      });
      afterEach(function(){
        crossroads.resetState();
        crossroads.removeAllRoutes();
        crossroads.routed.removeAll();
        crossroads.bypassed.removeAll();
        return crossroads.shouldTypecast = _prevTypecast;
      });
      describe('simple string route', function(){
        return specify('shold route basic strings', function(){
          var t1;
          t1 = 0;
          crossroads.addRoute('/foo', function(a){
            return t1++;
          });
          crossroads.parse('/bar');
          crossroads.parse('/foo');
          crossroads.parse('foo');
          expect(t1).toBe(2);
          specify('should pass params and allow multiple routes', function(){
            var t1, t2, t3;
            crossroads.addRoute('/{foo}', function(foo){
              var t1;
              return t1 = foo;
            });
            crossroads.addRoute('/{foo}/{bar}', function(foo, bar){
              var t2, t3;
              t2 = foo;
              return t3 = bar;
            });
            crossroads.parse('/lorem_ipsum');
            crossroads.parse('/maecennas/ullamcor');
            expect(t1).toBe('lorem_ipsum');
            expect(t2).toBe('maecennas');
            expect(t3).toBe('ullamcor');
            return specify('should dispatch matched signal', function(){
              var t1, t2, t3, a, b;
              a = crossroads.addRoute('/{foo}');
              a.matched.add(function(foo){
                var t1;
                return t1 = foo;
              });
              b = crossroads.addRoute('/{foo}/{bar}');
              b.matched.add(function(foo, bar){
                var t2, t3;
                t2 = foo;
                return t3 = bar;
              });
              crossroads.parse('/lorem_ipsum');
              crossroads.parse('/maecennas/ullamcor');
              expect(t1).toBe('lorem_ipsum');
              expect(t2).toBe('maecennas');
              return expect(t3).toBe('ullamcor');
            });
          });
          specify('should handle a word separator that isn\'t necessarily /', function(){
            var t1, t2, t3, t4, a, b;
            a = crossroads.addRoute('/{foo}_{bar}');
            a.matched.add(function(foo, bar){
              var t1, t2;
              t1 = foo;
              return t2 = bar;
            });
            b = crossroads.addRoute('/{foo}-{bar}');
            b.matched.add(function(foo, bar){
              var t3, t4;
              t3 = foo;
              return t4 = bar;
            });
            crossroads.parse('/lorem_ipsum');
            crossroads.parse('/maecennas-ullamcor');
            expect(t1).toBe('lorem');
            expect(t2).toBe('ipsum');
            expect(t3).toBe('maecennas');
            return expect(t4).toBe('ullamcor');
          });
          specify('should handle empty routes', function(){
            var calls, a;
            calls = 0;
            a = crossroads.addRoute();
            a.matched.add(function(foo, bar){
              expect(foo).toBeUndefined();
              expect(bar).toBeUndefined();
              return calls++;
            });
            crossroads.parse('/123/456');
            crossroads.parse('/maecennas/ullamcor');
            crossroads.parse('');
            return expect(calls).toBe(1);
          });
          specify('should handle empty strings', function(){
            var calls, a;
            calls = 0;
            a = crossroads.addRoute('');
            a.matched.add(function(foo, bar){
              expect(foo).toBeUndefined();
              expect(bar).toBeUndefined();
              return calls++;
            });
            crossroads.parse('/123/456');
            crossroads.parse('/maecennas/ullamcor');
            crossroads.parse('');
            return expect(calls).toBe(1);
          });
          return specify('should route `null` as empty string', function(){
            var calls, a;
            calls = 0;
            a = crossroads.addRoute('');
            a.matched.add(function(foo, bar){
              expect(foo).toBeUndefined();
              expect(bar).toBeUndefined();
              return calls++;
            });
            crossroads.parse('/123/456');
            crossroads.parse('/maecennas/ullamcor');
            crossroads.parse();
            return expect(calls).toBe(1);
          });
        });
      });
      return describe('simple string route', function(){
        specify('shold route basic strings', function(){
          var t1;
          t1 = 0;
          crossroads.addRoute('/foo', function(a){
            return t1++;
          });
          crossroads.parse('/bar');
          crossroads.parse('/foo');
          crossroads.parse('foo');
          return expect(t1).toBe(2);
        });
        specify('should pass params and allow multiple routes', function(){
          var t1, t2, t3;
          crossroads.addRoute('/{foo}', function(foo){
            var t1;
            return t1 = foo;
          });
          crossroads.addRoute('/{foo}/{bar}', function(foo, bar){
            var t2, t3;
            t2 = foo;
            return t3 = bar;
          });
          crossroads.parse('/lorem_ipsum');
          crossroads.parse('/maecennas/ullamcor');
          expect(t1).toBe('lorem_ipsum');
          expect(t2).toBe('maecennas');
          return expect(t3).toBe('ullamcor');
        });
        specify('should dispatch matched signal', function(){
          var t1, t2, t3, a, b;
          a = crossroads.addRoute('/{foo}');
          a.matched.add(function(foo){
            var t1;
            return t1 = foo;
          });
          b = crossroads.addRoute('/{foo}/{bar}');
          b.matched.add(function(foo, bar){
            var t2, t3;
            t2 = foo;
            return t3 = bar;
          });
          crossroads.parse('/lorem_ipsum');
          crossroads.parse('/maecennas/ullamcor');
          expect(t1).toBe('lorem_ipsum');
          expect(t2).toBe('maecennas');
          return expect(t3).toBe('ullamcor');
        });
        specify('should handle a word separator that isn\'t necessarily /', function(){
          var t1, t2, t3, t4, a, b;
          a = crossroads.addRoute('/{foo}_{bar}');
          a.matched.add(function(foo, bar){
            var t1, t2;
            t1 = foo;
            return t2 = bar;
          });
          b = crossroads.addRoute('/{foo}-{bar}');
          b.matched.add(function(foo, bar){
            var t3, t4;
            t3 = foo;
            return t4 = bar;
          });
          crossroads.parse('/lorem_ipsum');
          crossroads.parse('/maecennas-ullamcor');
          expect(t1).toBe('lorem');
          expect(t2).toBe('ipsum');
          expect(t3).toBe('maecennas');
          return expect(t4).toBe('ullamcor');
        });
        specify('should handle empty routes', function(){
          var calls, a;
          calls = 0;
          a = crossroads.addRoute();
          a.matched.add(function(foo, bar){
            expect(foo).toBeUndefined();
            expect(bar).toBeUndefined();
            return calls++;
          });
          crossroads.parse('/123/456');
          crossroads.parse('/maecennas/ullamcor');
          crossroads.parse('');
          return expect(calls).toBe(1);
        });
        specify('should handle empty strings', function(){
          var calls, a;
          calls = 0;
          a = crossroads.addRoute('');
          a.matched.add(function(foo, bar){
            expect(foo).toBeUndefined();
            expect(bar).toBeUndefined();
            return calls++;
          });
          crossroads.parse('/123/456');
          crossroads.parse('/maecennas/ullamcor');
          crossroads.parse('');
          return expect(calls).toBe(1);
        });
        return specify('should route `null` as empty string', function(){
          var calls, a;
          calls = 0;
          a = crossroads.addRoute('');
          a.matched.add(function(foo, bar){
            expect(foo).toBeUndefined();
            expect(bar).toBeUndefined();
            return calls++;
          });
          crossroads.parse('/123/456');
          crossroads.parse('/maecennas/ullamcor');
          crossroads.parse();
          return expect(calls).toBe(1);
        });
      });
    });
  });
}).call(this);
