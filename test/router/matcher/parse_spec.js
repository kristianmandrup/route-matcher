// Generated by LiveScript 1.2.0
(function(){
  var crossroads;
  crossroads = require('../../../crossroads');
  describe('crossroads.parse )', function(){
    var _prevTypecast;
    beforeEach(function(){
      var _prevTypecast;
      return _prevTypecast = crossroads.shouldTypecast;
    });
    afterEach(function(){
      crossroads.resetState();
      crossroads.removeAllRoutes();
      crossroads.routed.removeAll();
      crossroads.bypassed.removeAll();
      return crossroads.shouldTypecast = _prevTypecast;
    });
    describe('optional params', function(){
      specify('should capture optional params', function(){
        var calls, a;
        calls = 0;
        a = crossroads.addRoute('foo/:lorem:/:ipsum:/:dolor:/:sit:');
        a.matched.add(function(a, b, c, d){
          expect(a).toBe('lorem');
          expect(b).toBe('123');
          expect(c).toBe('true');
          expect(d).toBe('false');
          return calls++;
        });
        crossroads.parse('foo/lorem/123/true/false');
        return expect(calls).toBe(1);
      });
      return specify('should only pass matched params', function(){
        var calls, a;
        calls = 0;
        a = crossroads.addRoute('foo/:lorem:/:ipsum:/:dolor:/:sit:');
        a.matched.add(function(a, b, c, d){
          expect(a).toBe('lorem');
          expect(b).toBe('123');
          expect(c).toBeUndefined();
          expect(d).toBeUndefined();
          return calls++;
        });
        crossroads.parse('foo/lorem/123');
        return expect(calls).toBe(1);
      });
    });
    describe('regex route', function(){
      specify('should capture groups', function(){
        var calls, a;
        calls = 0;
        a = crossroads.addRoute(/^\/[0-9]+\/([0-9]+)$/);
        a.matched.add(function(foo, bar){
          expect(foo).toBe('456');
          expect(bar).toBeUndefined();
          return calls++;
        });
        crossroads.parse('/123/456');
        crossroads.parse('/maecennas/ullamcor');
        return expect(calls).toBe(1);
      });
      return specify('should capture even empty groups', function(){
        var calls, a;
        calls = 0;
        a = crossroads.addRoute(/^\/()\/([0-9]+)$/);
        a.matched.add(function(foo, bar){
          expect(foo).toBe('');
          expect(bar).toBe('456');
          return calls++;
        });
        crossroads.parse('#456');
        return expect(calls).toBe(1);
      });
    });
    describe('typecast values', function(){
      specify('should typecast values if shouldTypecast is set to true', function(){
        var calls, a;
        crossroads.shouldTypecast = true;
        calls = 0;
        a = crossroads.addRoute('{a}/{b}/{c}/{d}/{e}/{f}');
        a.matched.add(function(a, b, c, d, e, f){
          expect(a).toBe('lorem');
          expect(b).toBe(123);
          expect(c).toBe(true);
          expect(d).toBe(false);
          expect(e).toBe(null);
          expect(f).toBe(undefined);
          return calls++;
        });
        crossroads.parse('lorem/123/true/false/null/undefined');
        return expect(calls).toBe(1);
      });
      return specify('should not typecast if shouldTypecast is set to false', function(){
        var calls, a;
        crossroads.shouldTypecast = false;
        calls = 0;
        a = crossroads.addRoute('{lorem}/{ipsum}/{dolor}/{sit}');
        a.matched.add(function(a, b, c, d){
          expect(a).toBe('lorem');
          expect(b).toBe('123');
          expect(c).toBe('true');
          expect(d).toBe('false');
          return calls++;
        });
        crossroads.parse('lorem/123/true/false');
        return expect(calls).toBe(1);
      });
    });
    describe('rules.normalize_', function(){
      return specify('should normalize params before dispatching signal', function(){
        var t1, t2, t3, t4, t5, t6, t7, t8, myRoute;
        myRoute = crossroads.addRoute('{a}/{b}/:c:/:d:');
        myRoute.rules = {
          a: ['news', 'article'],
          b: /[\-0-9a-zA-Z]+/,
          request_: /\/[0-9]+\/|$/,
          normalize_: function(request, vals){
            var id, idRegex;
            idRegex = /^[0-9]+$/;
            if (deepEq$(vals.a, 'article', '===')) {
              id = vals.c;
            } else {
              if (idRegex.test(vals.b)) {
                id = vals.b;
              } else if (idRegex.test(vals.c)) {
                id = vals.c;
              }
            }
            return ['news', id];
          }
        };
        myRoute.matched.addOnce(function(a, b){
          var t1, t2;
          t1 = a;
          return t2 = b;
        });
        crossroads.parse('news/111/lorem-ipsum');
        myRoute.matched.addOnce(function(a, b){
          var t3, t4;
          t3 = a;
          return t4 = b;
        });
        crossroads.parse('news/foo/222/lorem-ipsum');
        myRoute.matched.addOnce(function(a, b){
          var t5, t6;
          t5 = a;
          return t6 = b;
        });
        crossroads.parse('news/333');
        myRoute.matched.addOnce(function(a, b){
          var t7, t8;
          t7 = a;
          return t8 = b;
        });
        crossroads.parse('article/news/444');
        expect(t1).toBe('news');
        expect(t2).toBe('111');
        expect(t3).toBe('news');
        expect(t4).toBe('222');
        expect(t5).toBe('news');
        expect(t6).toBe('333');
        expect(t7).toBe('news');
        return expect(t8).toBe('444');
      });
    });
    describe('crossroads.normalizeFn', function(){
      var prevNorm;
      beforeEach(function(){
        var prevNorm;
        return prevNorm = crossroads.normalizeFn;
      });
      afterEach(function(){
        return crossroads.normalizeFn = prevNorm;
      });
      specify('should work as a default normalize_', function(){
        var t1, t2, t3, t4, t5, t6, t7, t8, route1, route2;
        crossroads.normalizeFn = function(request, vals){
          var id, idRegex;
          idRegex = /^[0-9]+$/;
          if (deepEq$(vals.a, 'article', '===')) {
            id = vals.c;
          } else {
            if (idRegex.test(vals.b)) {
              id = vals.b;
            } else if (idRegex.test(vals.c)) {
              id = vals.c;
            }
          }
          return ['news', id];
        };
        route1 = crossroads.addRoute('news/{b}/:c:/:d:');
        route1.matched.addOnce(function(a, b){
          var t1, t2;
          t1 = a;
          return t2 = b;
        });
        crossroads.parse('news/111/lorem-ipsum');
        route2 = crossroads.addRoute('{a}/{b}/:c:/:d:');
        route2.rules = {
          a: ['news', 'article'],
          b: /[\-0-9a-zA-Z]+/,
          request_: /\/[0-9]+\/|$/,
          normalize_: function(req, vals){
            return ['foo', vals.b];
          }
        };
        route2.matched.addOnce(function(a, b){
          var t3, t4;
          t3 = a;
          return t4 = b;
        });
        crossroads.parse('article/333');
        expect(t1).toBe('news');
        expect(t2).toBe('111');
        expect(t3).toBe('foo');
        return expect(t4).toBe('333');
      });
      specify('should receive all values as an array on the special property `vals_`', function(){
        var t1, t2;
        crossroads.normalizeFn = function(request, vals){
          return [vals.vals_];
        };
        crossroads.addRoute('/{a}/{b}', function(params){
          var t1;
          return t1 = params;
        });
        crossroads.addRoute('/{a}', function(params){
          var t2;
          return t2 = params;
        });
        crossroads.parse('/foo/bar');
        crossroads.parse('/foo');
        expect(t1.join('')).toEqual(['foo', 'bar'].join(''));
        return expect(t2.join('')).toEqual(['foo'].join(''));
      });
      describe('NORM_AS_ARRAY', function(){
        return specify('should pass array', function(){
          var arg;
          crossroads.normalizeFn = crossroads.NORM_AS_ARRAY;
          crossroads.addRoute('/{a}/{b}', function(a){
            var arg;
            return arg = a;
          });
          crossroads.parse('/foo/bar');
          expect({}.toString.call(arg)).toEqual('[object Array]');
          expect(arg[0]).toEqual('foo');
          return expect(arg[1]).toEqual('bar');
        });
      });
      describe('NORM_AS_OBJECT', function(){
        return specify('should pass object', function(){
          var arg;
          crossroads.normalizeFn = crossroads.NORM_AS_OBJECT;
          crossroads.addRoute('/{a}/{b}', function(a){
            var arg;
            return arg = a;
          });
          crossroads.parse('/foo/bar');
          expect(arg.a).toEqual('foo');
          return expect(arg.b).toEqual('bar');
        });
      });
      return describe('normalizeFn = null', function(){
        return specify('should pass multiple args', function(){
          var arg1, arg2;
          crossroads.normalizeFn = null;
          crossroads.addRoute('/{a}/{b}', function(a, b){
            var arg1, arg2;
            arg1 = a;
            return arg2 = b;
          });
          crossroads.parse('/foo/bar');
          expect(arg1).toEqual('foo');
          return expect(arg2).toEqual('bar');
        });
      });
    });
    describe('priority', function(){
      specify('should enforce match order', function(){
        var calls, a, b;
        calls = 0;
        a = crossroads.addRoute('/{foo}/{bar}');
        a.matched.add(function(foo, bar){
          throw new Error('shouldn\'t match but matched ' + foo + ' ' + bar);
        });
        b = crossroads.addRoute('/{foo}/{bar}', null, 1);
        b.matched.add(function(foo, bar){
          expect(foo).toBe('123');
          expect(bar).toBe('456');
          return calls++;
        });
        crossroads.parse('/123/456');
        return expect(calls).toBe(1);
      });
      return specify('shouldnt matter if there is a gap between priorities', function(){
        var calls, fun, a, fun2, b;
        calls = 0;
        fun = function(foo, bar){
          throw new Error('shouldn\'t match but matched ' + foo + ' ' + bar);
        };
        a = crossroads.addRoute('/{foo}/{bar}', fun, 4);
        fun2 = function(foo, bar){
          expect(foo).toBe('123');
          expect(bar).toBe('456');
          return calls++;
        };
        b = crossroads.addRoute('/{foo}/{bar}', fun2, 999);
        crossroads.parse('/123/456');
        return expect(calls).toBe(1);
      });
    });
    return describe('validate params before dispatch', function(){
      specify('should ignore routes that don\'t validate', function(){
        var calls, pattern, a, b;
        calls = '';
        pattern = '{foo}-{bar}';
        a = crossroads.addRoute(pattern);
        a.matched.add(function(foo, bar){
          expect(foo).toBe('lorem');
          expect(bar).toBe('123');
          return calls += 'a';
        });
        a.rules = {
          foo: /\w+/,
          bar: function(value, request, matches){
            return deepEq$(request, 'lorem-123', '===');
          }
        };
        b = crossroads.addRoute(pattern);
        b.matched.add(function(foo, bar){
          expect(foo).toBe('123');
          expect(bar).toBe('ullamcor');
          return calls += 'b';
        });
        b.rules = {
          foo: ['123', '456', '567', '2'],
          bar: /ullamcor/
        };
        crossroads.parse('45-ullamcor');
        crossroads.parse('123-ullamcor');
        crossroads.parse('lorem-123');
        crossroads.parse('lorem-555');
        return expect(calls).toBe('ba');
      });
      return specify('should consider invalid rules as not matching', function(){
        var pattern, a, b;
        pattern = '{foo}-{bar}';
        a = crossroads.addRoute(pattern);
        a.matched.add(function(foo, bar){
          throw new Error('first route was matched when it should not have been');
        });
        a.rules = {
          foo: 'lorem',
          bar: 123
        };
        b = crossroads.addRoute(pattern);
        b.matched.add(function(foo, bar){
          throw new Error('second route was matched when it should not have been');
        });
        b.rules = {
          foo: false,
          bar: void 8
        };
        crossroads.parse('45-ullamcor');
        return crossroads.parse('lorem-123');
      });
    });
  });
  function deepEq$(x, y, type){
    var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
        has = function (obj, key) { return hasOwnProperty.call(obj, key); };
    var first = true;
    return eq(x, y, []);
    function eq(a, b, stack) {
      var className, length, size, result, alength, blength, r, key, ref, sizeB;
      if (a == null || b == null) { return a === b; }
      if (a.__placeholder__ || b.__placeholder__) { return true; }
      if (a === b) { return a !== 0 || 1 / a == 1 / b; }
      className = toString.call(a);
      if (toString.call(b) != className) { return false; }
      switch (className) {
        case '[object String]': return a == String(b);
        case '[object Number]':
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          return +a == +b;
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') { return false; }
      length = stack.length;
      while (length--) { if (stack[length] == a) { return true; } }
      stack.push(a);
      size = 0;
      result = true;
      if (className == '[object Array]') {
        alength = a.length;
        blength = b.length;
        if (first) { 
          switch (type) {
          case '===': result = alength === blength; break;
          case '<==': result = alength <= blength; break;
          case '<<=': result = alength < blength; break;
          }
          size = alength;
          first = false;
        } else {
          result = alength === blength;
          size = alength;
        }
        if (result) {
          while (size--) {
            if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
          }
        }
      } else {
        if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
          return false;
        }
        for (key in a) {
          if (has(a, key)) {
            size++;
            if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
          }
        }
        if (result) {
          sizeB = 0;
          for (key in b) {
            if (has(b, key)) { ++sizeB; }
          }
          if (first) {
            if (type === '<<=') {
              result = size < sizeB;
            } else if (type === '<==') {
              result = size <= sizeB
            } else {
              result = size === sizeB;
            }
          } else {
            first = false;
            result = size === sizeB;
          }
        }
      }
      stack.pop();
      return result;
    }
  }
}).call(this);
