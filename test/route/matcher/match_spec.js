// Generated by LiveScript 1.2.0
(function(){
  describe('Route Match', function(){
    _prevTypecast;
    _prevCase;
    beforeEach(function(){
      var _prevTypecast, _prevCase;
      _prevTypecast = crossroads.shouldTypecast;
      return _prevCase = crossroads.ignoreCase;
    });
    afterEach(function(){
      crossroads.removeAllRoutes();
      crossroads.resetState();
      crossroads.shouldTypecast = _prevTypecast;
      return crossroads.ignoreCase = _prevCase;
    });
    specify('should match simple string', function(){
      var r1;
      r1 = crossroads.addRoute('/lorem-ipsum');
      expect(r1.match('/lorem-ipsum')).toBe(true);
      expect(r1.match('/lorem-ipsum/')).toBe(true);
      return expect(r1.match('/lorem-ipsum/dolor')).toBe(false);
    });
    specify('should ignore trailing slash on pattern', function(){
      var r1;
      r1 = crossroads.addRoute('/lorem-ipsum/');
      expect(r1.match('/lorem-ipsum')).toBe(true);
      expect(r1.match('/lorem-ipsum/')).toBe(true);
      return expect(r1.match('/lorem-ipsum/dolor')).toBe(false);
    });
    specify('should match params', function(){
      var s;
      s = crossroads.addRoute('/{foo}');
      expect(s.match('/lorem-ipsum')).toBe(true);
      expect(s.match('/lorem-ipsum/')).toBe(true);
      expect(s.match('/lorem-ipsum/dolor')).toBe(false);
      expect(s.match('lorem-ipsum')).toBe(true);
      expect(s.match('/123')).toBe(true);
      expect(s.match('/123/')).toBe(true);
      expect(s.match('123')).toBe(true);
      return expect(s.match('123/45')).toBe(false);
    });
    specify('should match optional params', function(){
      var s;
      s = crossroads.addRoute(':bar:');
      expect(s.match('lorem-ipsum')).toBe(true);
      expect(s.match('')).toBe(true);
      expect(s.match('lorem-ipsum/dolor')).toBe(false);
      return expect(s.match('/lorem-ipsum/')).toBe(true);
    });
    specify('should match normal params and optional params', function(){
      var s;
      s = crossroads.addRoute('/{foo}/:bar:');
      expect(s.match('/lorem-ipsum')).toBe(true);
      expect(s.match('/lorem-ipsum/')).toBe(true);
      expect(s.match('/lorem-ipsum/dolor')).toBe(true);
      return expect(s.match('123/45')).toBe(true);
    });
    specify('should work even with optional params on the middle of pattern', function(){
      var a, b, c, d;
      a = crossroads.addRoute('/{foo}/:bar:/{ipsum}');
      expect(a.match('/123/45/asd')).toBe(true);
      expect(a.match('/123/asd')).toBe(true);
      b = crossroads.addRoute('/{foo}:bar:{ipsum}');
      expect(b.match('/123/45/asd')).toBe(true);
      expect(b.match('/123/45')).toBe(true);
      c = crossroads.addRoute('/{foo}:bar:/ipsum');
      expect(c.match('/123/45/ipsum')).toBe(true);
      expect(c.match('/123/ipsum')).toBe(true);
      d = crossroads.addRoute('/{foo}:bar:ipsum');
      expect(d.match('/123/ipsum')).toBe(true);
      return expect(d.match('/123/45/ipsum')).toBe(true);
    });
    specify('should support multiple consecutive optional params', function(){
      var s;
      s = crossroads.addRoute('/123/:bar:/:ipsum:');
      expect(s.match('/123')).toBe(true);
      expect(s.match('/123/')).toBe(true);
      expect(s.match('/123/asd')).toBe(true);
      expect(s.match('/123/asd/45')).toBe(true);
      expect(s.match('/123/asd/45/')).toBe(true);
      return expect(s.match('/123/asd/45/qwe')).toBe(false);
    });
    specify('should not be case sensitive by default', function(){
      var s;
      s = crossroads.addRoute('foo/bar');
      expect(s.match('foo')).toBe(false);
      expect(s.match('Foo')).toBe(false);
      expect(s.match('foo/bar')).toBe(true);
      expect(s.match('Foo/Bar')).toBe(true);
      return expect(s.match('FoO/BAR')).toBe(true);
    });
    specify('should be allow toggling case sensitivity', function(){
      var s;
      crossroads.ignoreCase = true;
      s = crossroads.addRoute('foo/bar');
      expect(s.match('foo')).toBe(false);
      expect(s.match('Foo')).toBe(false);
      expect(s.match('foo/bar')).toBe(true);
      expect(s.match('Foo/Bar')).toBe(true);
      return expect(s.match('FoO/BAR')).toBe(true);
    });
    describe('rest params', function(){
      specify('should support rest params', function(){
        var s;
        s = crossroads.addRoute('/123/{bar}/:ipsum*:');
        expect(s.match('/123')).toBe(false);
        expect(s.match('/123/')).toBe(false);
        expect(s.match('/123/asd')).toBe(true);
        expect(s.match('/123/asd/45')).toBe(true);
        expect(s.match('/123/asd/45/')).toBe(true);
        expect(s.match('/123/asd/45/qwe')).toBe(true);
        return expect(s.match('/456/asd/45/qwe')).toBe(false);
      });
      return specify('should work even in the middle of pattern', function(){
        var s;
        s = crossroads.addRoute('/foo/:bar*:/edit');
        expect(s.match('/foo')).toBe(false);
        expect(s.match('/foo/')).toBe(false);
        expect(s.match('/foo/edit')).toBe(true);
        expect(s.match('/foo/asd')).toBe(false);
        expect(s.match('/foo/asd/edit')).toBe(true);
        expect(s.match('/foo/asd/edit/')).toBe(true);
        expect(s.match('/foo/asd/123/edit')).toBe(true);
        return expect(s.match('/foo/asd/edit/qwe')).toBe(false);
      });
    });
    describe('query string', function(){
      specify('should match query string as first segment', function(){
        var r;
        r = crossroads.addRoute('{?q}');
        expect(r.match('')).toBe(false);
        expect(r.match('foo')).toBe(false);
        expect(r.match('/foo')).toBe(false);
        expect(r.match('foo/')).toBe(false);
        expect(r.match('/foo/')).toBe(false);
        expect(r.match('?foo')).toBe(true);
        expect(r.match('?foo=bar')).toBe(true);
        return expect(r.match('?foo=bar&lorem=123')).toBe(true);
      });
      specify('should match optional query string as first segment', function(){
        var r;
        r = crossroads.addRoute(':?q:');
        expect(r.match('')).toBe(true);
        expect(r.match('foo')).toBe(false);
        expect(r.match('/foo')).toBe(false);
        expect(r.match('foo/')).toBe(false);
        expect(r.match('/foo/')).toBe(false);
        expect(r.match('?foo')).toBe(true);
        expect(r.match('?foo=bar')).toBe(true);
        return expect(r.match('?foo=bar&lorem=123')).toBe(true);
      });
      specify('should match query string as 2nd segment', function(){
        var r;
        r = crossroads.addRoute('{a}{?q}');
        expect(r.match('')).toBe(false);
        expect(r.match('foo')).toBe(false);
        expect(r.match('/foo')).toBe(false);
        expect(r.match('foo/')).toBe(false);
        expect(r.match('/foo/')).toBe(false);
        expect(r.match('foo?foo')).toBe(true);
        expect(r.match('foo?foo=bar')).toBe(true);
        return expect(r.match('foo?foo=bar&lorem=123')).toBe(true);
      });
      specify('should match optional query string as 2nd segment', function(){
        var r;
        r = crossroads.addRoute('{a}:?q:');
        expect(r.match('')).toBe(false);
        expect(r.match('foo')).toBe(true);
        expect(r.match('/foo')).toBe(true);
        expect(r.match('foo/')).toBe(true);
        expect(r.match('/foo/')).toBe(true);
        expect(r.match('foo?foo')).toBe(true);
        expect(r.match('foo?foo=bar')).toBe(true);
        return expect(r.match('foo?foo=bar&lorem=123')).toBe(true);
      });
      specify('should match query string as middle segment', function(){
        var r;
        r = crossroads.addRoute('{a}{?q}#{hash}');
        expect(r.match('')).toBe(false);
        expect(r.match('foo')).toBe(false);
        expect(r.match('/foo')).toBe(false);
        expect(r.match('foo/')).toBe(false);
        expect(r.match('/foo/')).toBe(false);
        expect(r.match('foo?foo')).toBe(false);
        expect(r.match('foo?foo#bar')).toBe(true);
        expect(r.match('foo?foo=bar#bar')).toBe(true);
        return expect(r.match('foo?foo=bar&lorem=123#bar')).toBe(true);
      });
      specify('should match optional query string as middle segment', function(){
        var r;
        r = crossroads.addRoute('{a}:?q::hash:');
        expect(r.match('')).toBe(false);
        expect(r.match('foo')).toBe(true);
        expect(r.match('/foo')).toBe(true);
        expect(r.match('foo/')).toBe(true);
        expect(r.match('/foo/')).toBe(true);
        expect(r.match('foo?foo')).toBe(true);
        expect(r.match('foo?foo=bar')).toBe(true);
        expect(r.match('foo?foo=bar#bar')).toBe(true);
        expect(r.match('foo?foo=bar&lorem=123')).toBe(true);
        return expect(r.match('foo?foo=bar&lorem=123#bar')).toBe(true);
      });
      return specify('should match query string even if not using the special query syntax', function(){
        var r;
        r = crossroads.addRoute('{a}?{q}#{hash}');
        expect(r.match('')).toBe(false);
        expect(r.match('foo')).toBe(false);
        expect(r.match('/foo')).toBe(false);
        expect(r.match('foo/')).toBe(false);
        expect(r.match('/foo/')).toBe(false);
        expect(r.match('foo?foo')).toBe(false);
        expect(r.match('foo?foo#bar')).toBe(true);
        expect(r.match('foo?foo=bar#bar')).toBe(true);
        return expect(r.match('foo?foo=bar&lorem=123#bar')).toBe(true);
      });
    });
    describe('slash between params are optional', function(){
      describe('between required params', function(){
        return specify('after other param', function(){
          var a;
          a = crossroads.addRoute('{bar}{ipsum}');
          expect(a.match('123')).toBe(false);
          expect(a.match('123/')).toBe(false);
          expect(a.match('123/asd')).toBe(true);
          expect(a.match('123/asd/')).toBe(true);
          expect(a.match('123/asd/45')).toBe(false);
          expect(a.match('123/asd/45/')).toBe(false);
          return expect(a.match('123/asd/45/qwe')).toBe(false);
        });
      });
      describe('between optional params', function(){
        return specify('optional after other optional param', function(){
          var a;
          a = crossroads.addRoute(':bar::ipsum:');
          expect(a.match('123')).toBe(true);
          expect(a.match('123/')).toBe(true);
          expect(a.match('123/asd')).toBe(true);
          expect(a.match('123/asd/')).toBe(true);
          expect(a.match('123/asd/45')).toBe(false);
          expect(a.match('123/asd/45/')).toBe(false);
          return expect(a.match('123/asd/45/qwe')).toBe(false);
        });
      });
      return describe('mixed', function(){
        specify('between normal + optional', function(){
          var a;
          a = crossroads.addRoute('/{foo}:bar:');
          return expect(a.match('/lorem-ipsum/dolor')).toBe(true);
        });
        specify('between normal + optional*2', function(){
          var b;
          b = crossroads.addRoute('/{foo}:bar::ipsum:');
          expect(b.match('/123')).toBe(true);
          expect(b.match('/123/asd')).toBe(true);
          expect(b.match('/123/asd/')).toBe(true);
          expect(b.match('/123/asd/qwe')).toBe(true);
          expect(b.match('/123/asd/qwe/')).toBe(true);
          expect(b.match('/123/asd/qwe/asd')).toBe(false);
          return expect(b.match('/123/asd/qwe/asd/')).toBe(false);
        });
        specify('with slashes all', function(){
          var c;
          c = crossroads.addRoute('bar/{foo}/:bar:/:ipsum:');
          expect(c.match('bar/123')).toBe(true);
          expect(c.match('bar/123/')).toBe(true);
          expect(c.match('bar/123/asd')).toBe(true);
          expect(c.match('bar/123/asd/')).toBe(true);
          expect(c.match('bar/123/asd/45')).toBe(true);
          expect(c.match('bar/123/asd/45/')).toBe(true);
          return expect(c.match('bar/123/asd/45/qwe')).toBe(false);
        });
        specify('required param after \\w/', function(){
          var a;
          a = crossroads.addRoute('/123/{bar}{ipsum}');
          expect(a.match('/123')).toBe(false);
          expect(a.match('/123/')).toBe(false);
          expect(a.match('/123/asd')).toBe(false);
          expect(a.match('/123/asd/')).toBe(false);
          expect(a.match('/123/asd/45')).toBe(true);
          expect(a.match('/123/asd/45/')).toBe(true);
          return expect(a.match('/123/asd/45/qwe')).toBe(false);
        });
        return specify('optional params after \\w/', function(){
          var a;
          a = crossroads.addRoute('/123/:bar::ipsum:');
          expect(a.match('/123')).toBe(true);
          expect(a.match('/123/')).toBe(true);
          expect(a.match('/123/asd')).toBe(true);
          expect(a.match('/123/asd/')).toBe(true);
          expect(a.match('/123/asd/45')).toBe(true);
          expect(a.match('/123/asd/45/')).toBe(true);
          return expect(a.match('/123/asd/45/qwe')).toBe(false);
        });
      });
    });
    describe('slash is required between word and param', function(){
      specify('required param after \\w', function(){
        var a;
        a = crossroads.addRoute('/123{bar}{ipsum}');
        expect(a.match('/123')).toBe(false);
        expect(a.match('/123/')).toBe(false);
        expect(a.match('/123/asd')).toBe(false);
        expect(a.match('/123/asd/')).toBe(false);
        expect(a.match('/123/asd/45')).toBe(false);
        expect(a.match('/123/asd/45/')).toBe(false);
        expect(a.match('/123/asd/45/qwe')).toBe(false);
        expect(a.match('/123asd')).toBe(false);
        expect(a.match('/123asd/')).toBe(false);
        expect(a.match('/123asd/45')).toBe(true);
        expect(a.match('/123asd/45/')).toBe(true);
        return expect(a.match('/123asd/45/qwe')).toBe(false);
      });
      return specify('optional param after \\w', function(){
        var a;
        a = crossroads.addRoute('/123:bar::ipsum:');
        expect(a.match('/123')).toBe(true);
        expect(a.match('/123/')).toBe(true);
        expect(a.match('/123/asd')).toBe(true);
        expect(a.match('/123/asd/')).toBe(true);
        expect(a.match('/123/asd/45')).toBe(false);
        expect(a.match('/123/asd/45/')).toBe(false);
        expect(a.match('/123/asd/45/qwe')).toBe(false);
        expect(a.match('/123asd')).toBe(true);
        expect(a.match('/123asd/')).toBe(true);
        expect(a.match('/123asd/45')).toBe(true);
        expect(a.match('/123asd/45/')).toBe(true);
        return expect(a.match('/123asd/45/qwe')).toBe(false);
      });
    });
    describe('strict slash rules', function(){
      afterEach(function(){
        return crossroads.patternLexer.loose;
      });
      return specify('should only match if traling slashes match the original pattern', function(){
        var a, b, c, d;
        crossroads.patternLexer.strict();
        a = crossroads.addRoute('{foo}');
        expect(a.match('foo')).toBe(true);
        expect(a.match('/foo')).toBe(false);
        expect(a.match('foo/')).toBe(false);
        expect(a.match('/foo/')).toBe(false);
        b = crossroads.addRoute('/{foo}');
        expect(b.match('foo')).toBe(false);
        expect(b.match('/foo')).toBe(true);
        expect(b.match('foo/')).toBe(false);
        expect(b.match('/foo/')).toBe(false);
        c = crossroads.addRoute('');
        expect(c.match()).toBe(true);
        expect(c.match('')).toBe(true);
        expect(c.match('/')).toBe(false);
        expect(c.match('foo')).toBe(false);
        d = crossroads.addRoute('/');
        expect(d.match()).toBe(false);
        expect(d.match('')).toBe(false);
        expect(d.match('/')).toBe(true);
        return expect(d.match('foo')).toBe(false);
      });
    });
    describe('loose slash rules', function(){
      beforeEach(function(){
        return crossroads.patternLexer.loose;
      });
      return specify('should treat single slash and empty string as same', function(){
        var c, d;
        c = crossroads.addRoute('');
        expect(c.match()).toBe(true);
        expect(c.match('')).toBe(true);
        expect(c.match('/')).toBe(true);
        expect(c.match('foo')).toBe(false);
        d = crossroads.addRoute('/');
        expect(d.match()).toBe(true);
        expect(d.match('')).toBe(true);
        expect(d.match('/')).toBe(true);
        return expect(d.match('foo')).toBe(false);
      });
    });
    describe('legacy slash rules', function(){
      beforeEach(function(){
        return crossroads.patternLexer.legacy();
      });
      afterEach(function(){
        return crossroads.patternLexer.loose();
      });
      specify('should treat single slash and empty string as same', function(){
        var c, d;
        c = crossroads.addRoute('');
        expect(c.match()).toBe(true);
        expect(c.match('')).toBe(true);
        expect(c.match('/')).toBe(true);
        expect(c.match('foo')).toBe(false);
        d = crossroads.addRoute('/');
        expect(d.match()).toBe(true);
        expect(d.match('')).toBe(true);
        expect(d.match('/')).toBe(true);
        return expect(d.match('foo')).toBe(false);
      });
      specify('slash at end of string is optional', function(){
        var a;
        a = crossroads.addRoute('/foo');
        expect(a.match('/foo')).toEqual(true);
        expect(a.match('/foo/')).toEqual(true);
        return expect(a.match('/foo/bar')).toEqual(false);
      });
      return specify('slash at begin of string is required', function(){
        var a;
        a = crossroads.addRoute('/foo');
        expect(a.match('/foo')).toEqual(true);
        expect(a.match('/foo/')).toEqual(true);
        expect(a.match('foo')).toEqual(false);
        expect(a.match('foo/')).toEqual(false);
        return expect(a.match('/foo/bar')).toEqual(false);
      });
    });
    return describe('rules', function(){
      describe('basic rules', function(){
        specify('should allow array options', function(){
          var s;
          s = crossroads.addRoute('/{foo}/{bar}');
          s.rules = {
            foo: ['lorem-ipsum', '123'],
            bar: ['DoLoR', '45']
          };
          expect(s.match('/lorem-ipsum')).toBe(false);
          expect(s.match('/lorem-ipsum/DoLoR')).toBe(true);
          expect(s.match('/LoReM-IpSuM/DOLoR')).toBe(true);
          expect(s.match('lorem-ipsum')).toBe(false);
          expect(s.match('/123')).toBe(false);
          expect(s.match('123')).toBe(false);
          expect(s.match('/123/123')).toBe(false);
          return expect(s.match('/123/45')).toBe(true);
        });
        specify('should change array validation behavior when ignoreCase is false', function(){
          var s;
          crossroads.ignoreCase = false;
          s = crossroads.addRoute('/{foo}/{bar}');
          s.rules = {
            foo: ['lorem-ipsum', '123'],
            bar: ['DoLoR', '45']
          };
          expect(s.match('/lorem-ipsum')).toBe(false);
          expect(s.match('/lorem-ipsum/dolor')).toBe(false);
          expect(s.match('/lorem-ipsum/DoLoR')).toBe(true);
          expect(s.match('/LoReM-IpSuM/DOLoR')).toBe(false);
          expect(s.match('lorem-ipsum')).toBe(false);
          expect(s.match('/123')).toBe(false);
          expect(s.match('123')).toBe(false);
          expect(s.match('/123/123')).toBe(false);
          return expect(s.match('/123/45')).toBe(true);
        });
        specify('should allow RegExp options', function(){
          var s;
          s = crossroads.addRoute('/{foo}/{bar}');
          s.rules = {
            foo: /(^[a-z0-9\-]+$)/,
            bar: /(.+)/
          };
          expect(s.match('/lorem-ipsum')).toBe(false);
          expect(s.match('/lorem-ipsum/dolor')).toBe(true);
          expect(s.match('lorem-ipsum')).toBe(false);
          expect(s.match('/123')).toBe(false);
          expect(s.match('123')).toBe(false);
          return expect(s.match('/123/45')).toBe(true);
        });
        specify('should allow function rule', function(){
          var s;
          s = crossroads.addRoute('/{foo}/{bar}/{ipsum}');
          s.rules = {
            foo: function(val, request, params){
              return deepEq$(val, 'lorem-ipsum', '===') || deepEq$(val, '123', '===');
            },
            bar: function(val, request, params){
              return !deepEq$(request, '/lorem-ipsum', '===');
            },
            ipsum: function(val, request, params){
              return (deepEq$(params.bar, 'dolor', '===') && deepEq$(params.ipsum, 'sit-amet', '===')) || (deepEq$(params.bar, '45', '===') && deepEq$(params.ipsum, '67', '==='));
            }
          };
          expect(s.match('/lorem-ipsum')).toBe(false);
          expect(s.match('/lorem-ipsum/dolor/sit-amet')).toBe(true);
          expect(s.match('lorem-ipsum')).toBe(false);
          expect(s.match('/123')).toBe(false);
          expect(s.match('123')).toBe(false);
          expect(s.match('/123/44/55')).toBe(false);
          return expect(s.match('/123/45/67')).toBe(true);
        });
        specify('should work with mixed rules', function(){
          var s;
          s = crossroads.addRoute('/{foo}/{bar}/{ipsum}');
          s.rules = {
            foo: function(val, request, params){
              return deepEq$(val, 'lorem-ipsum', '===') || deepEq$(val, '123', '===');
            },
            bar: ['dolor', '45'],
            ipsum: /(sit-amet|67)/
          };
          expect(s.match('/lorem-ipsum')).toBe(false);
          expect(s.match('/lorem-ipsum/dolor/sit-amet')).toBe(true);
          expect(s.match('lorem-ipsum')).toBe(false);
          expect(s.match('/123')).toBe(false);
          expect(s.match('123')).toBe(false);
          return expect(s.match('/123/45/67')).toBe(true);
        });
        specify('should only check rules of optional segments if param exists', function(){
          var a;
          a = crossroads.addRoute('/123/:a:/:b:/:c:');
          a.rules = {
            a: /^\w+$/,
            b: function(val){
              return deepEq$(val, 'ipsum', '===');
            },
            c: ['lorem', 'bar']
          };
          expect(a.match('/123')).toBe(true);
          expect(a.match('/123/')).toBe(true);
          expect(a.match('/123/asd')).toBe(true);
          expect(a.match('/123/asd/')).toBe(true);
          expect(a.match('/123/asd/ipsum/')).toBe(true);
          expect(a.match('/123/asd/ipsum/bar')).toBe(true);
          expect(a.match('/123/asd/45')).toBe(false);
          expect(a.match('/123/asd/45/qwe')).toBe(false);
          expect(a.match('/123/as#%d&/ipsum')).toBe(false);
          return expect(a.match('/123/asd/ipsum/nope')).toBe(false);
        });
        return specify('should work with shouldTypecast=false', function(){
          var s;
          s = crossroads.addRoute('/{foo}/{bar}/{ipsum}');
          crossroads.shouldTypecast = false;
          s.rules = {
            foo: function(val, request, params){
              return deepEq$(val, 'lorem-ipsum', '===') || deepEq$(val, '123', '===');
            },
            bar: ['dolor', '45'],
            ipsum: /(sit-amet|67)/
          };
          expect(s.match('/lorem-ipsum')).toBe(false);
          expect(s.match('/lorem-ipsum/dolor/sit-amet')).toBe(true);
          expect(s.match('lorem-ipsum')).toBe(false);
          expect(s.match('/123')).toBe(false);
          expect(s.match('123')).toBe(false);
          return expect(s.match('/123/45/67')).toBe(true);
        });
      });
      describe('query string', function(){
        specify('should validate with array', function(){
          var r;
          r = crossroads.addRoute('/foo.php{?query}');
          r.rules = {
            '?query': ['lorem=ipsum&dolor=456', 'amet=789']
          };
          expect(r.match('foo.php?bar=123&ipsum=dolor')).toBe(false);
          expect(r.match('foo.php?lorem=ipsum&dolor=456')).toBe(true);
          return expect(r.match('foo.php?amet=789')).toBe(true);
        });
        specify('should validate with RegExp', function(){
          var r;
          r = crossroads.addRoute('/foo.php{?query}');
          r.rules = {
            '?query': /^lorem=\w+&dolor=\d+$/
          };
          expect(r.match('foo.php?bar=123&ipsum=dolor')).toBe(false);
          expect(r.match('foo.php?lorem=ipsum&dolor=12345')).toBe(true);
          return expect(r.match('foo.php?lorem=ipsum&dolor=amet')).toBe(false);
        });
        return specify('should validate with Function', function(){
          var r;
          r = crossroads.addRoute('/foo.php{?query}');
          crossroads.shouldTypecast = true;
          r.rules = {
            '?query': function(val, req, vals){
              return deepEq$(val.lorem, 'ipsum', '===') && deepEq$(typeof val.dolor, 'number', '===');
            }
          };
          expect(r.match('foo.php?bar=123&ipsum=dolor')).toBe(false);
          expect(r.match('foo.php?lorem=ipsum&dolor=12345')).toBe(true);
          return expect(r.match('foo.php?lorem=ipsum&dolor=amet')).toBe(false);
        });
      });
      describe('path alias', function(){
        specify('should work with string pattern', function(){
          var s;
          s = crossroads.addRoute('/{foo}/{bar}/{ipsum}');
          s.rules = {
            0: ['lorem-ipsum', '123'],
            1: function(val, request, params){
              return !deepEq$(request, '/lorem-ipsum', '===');
            },
            2: /^(sit-amet|67)$/
          };
          expect(s.match('/lorem-ipsum')).toBe(false);
          expect(s.match('/lorem-ipsum/dolor/sit-amet')).toBe(true);
          expect(s.match('lorem-ipsum')).toBe(false);
          expect(s.match('/123')).toBe(false);
          expect(s.match('123')).toBe(false);
          expect(s.match('/123/44/55')).toBe(false);
          return expect(s.match('/123/45/67')).toBe(true);
        });
        return specify('should work with RegExp pattern', function(){
          var s;
          s = crossroads.addRoute(/([\-\w]+)\/([\-\w]+)\/([\-\w]+)/);
          s.rules = {
            0: ['lorem-ipsum', '123'],
            1: function(val, request, params){
              return !deepEq$(request, '/lorem-ipsum', '===');
            },
            2: /^(sit-amet|67)$/
          };
          expect(s.match('/lorem-ipsum')).toBe(false);
          expect(s.match('/lorem-ipsum/dolor/sit-amet')).toBe(true);
          expect(s.match('lorem-ipsum')).toBe(false);
          expect(s.match('/123')).toBe(false);
          expect(s.match('123')).toBe(false);
          expect(s.match('/123/44/55')).toBe(false);
          return expect(s.match('/123/45/67')).toBe(true);
        });
      });
      describe('request_', function(){
        specify('should validate whole request', function(){
          var s;
          s = crossroads.addRoute(/^([a-z0-9]+)$/);
          s.rules = {
            request_: function(request){
              return !deepEq$(request, '555', '===');
            }
          };
          expect(s.match('lorem')).toBe(true);
          expect(s.match('lorem/dolor/sit-amet')).toBe(false);
          expect(s.match('lorem-ipsum')).toBe(false);
          expect(s.match('123')).toBe(true);
          return expect(s.match('555')).toBe(false);
        });
        specify('should execute after other rules', function(){
          var s;
          s = crossroads.addRoute('/{foo}/{bar}/{ipsum}');
          s.rules = {
            foo: function(val, request, params){
              return deepEq$(val, 'lorem-ipsum', '===') || deepEq$(val, '123', '===');
            },
            bar: ['dolor', '45'],
            ipsum: /(sit-amet|67|555)/,
            request_: function(request){
              return !deepEq$(request, '/123/45/555', '===');
            }
          };
          expect(s.match('/lorem-ipsum')).toBe(false);
          expect(s.match('/lorem-ipsum/dolor/sit-amet')).toBe(true);
          expect(s.match('lorem-ipsum')).toBe(false);
          expect(s.match('/123')).toBe(false);
          expect(s.match('123')).toBe(false);
          expect(s.match('/123/45/67')).toBe(true);
          return expect(s.match('/123/45/555')).toBe(false);
        });
        specify('can be an array', function(){
          var s;
          s = crossroads.addRoute(/^([a-z0-9]+)$/);
          s.rules = {
            request_: ['lorem', '123']
          };
          expect(s.match('lorem')).toBe(true);
          expect(s.match('lorem/dolor/sit-amet')).toBe(false);
          expect(s.match('lorem-ipsum')).toBe(false);
          expect(s.match('123')).toBe(true);
          return expect(s.match('555')).toBe(false);
        });
        specify('can be a RegExp', function(){
          var s;
          s = crossroads.addRoute(/^([a-z0-9]+)$/);
          s.rules = {
            request_: /^(lorem|123)$/
          };
          expect(s.match('lorem')).toBe(true);
          expect(s.match('lorem/dolor/sit-amet')).toBe(false);
          expect(s.match('lorem-ipsum')).toBe(false);
          expect(s.match('123')).toBe(true);
          return expect(s.match('555')).toBe(false);
        });
        return specify('should work with optional params', function(){
          var s;
          s = crossroads.addRoute(':foo:');
          s.rules = {
            request_: /^(lorem|123|)$/
          };
          expect(s.match('lorem')).toBe(true);
          expect(s.match('lorem/dolor/sit-amet')).toBe(false);
          expect(s.match('lorem-ipsum')).toBe(false);
          expect(s.match('123')).toBe(true);
          expect(s.match('555')).toBe(false);
          return expect(s.match('')).toBe(true);
        });
      });
      return describe('normalize_', function(){
        return specify('should ignore normalize_ since it isn\'t a validation rule', function(){
          var calledNormalize, s;
          calledNormalize = false;
          s = crossroads.addRoute('/{foo}/{bar}/{ipsum}');
          s.rules = {
            foo: function(val, request, params){
              return deepEq$(val, 'lorem-ipsum', '===') || deepEq$(val, '123', '===');
            },
            bar: ['dolor', '45'],
            ipsum: /(sit-amet|67)/,
            normalize_: function(){
              var calledNormalize;
              calledNormalize = true;
              return [true];
            }
          };
          expect(calledNormalize).toBe(false);
          expect(s.match('/lorem-ipsum')).toBe(false);
          expect(s.match('/lorem-ipsum/dolor/sit-amet')).toBe(true);
          expect(s.match('lorem-ipsum')).toBe(false);
          expect(s.match('/123')).toBe(false);
          expect(s.match('123')).toBe(false);
          return expect(s.match('/123/45/67')).toBe(true);
        });
      });
    });
  });
  function deepEq$(x, y, type){
    var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
        has = function (obj, key) { return hasOwnProperty.call(obj, key); };
    var first = true;
    return eq(x, y, []);
    function eq(a, b, stack) {
      var className, length, size, result, alength, blength, r, key, ref, sizeB;
      if (a == null || b == null) { return a === b; }
      if (a.__placeholder__ || b.__placeholder__) { return true; }
      if (a === b) { return a !== 0 || 1 / a == 1 / b; }
      className = toString.call(a);
      if (toString.call(b) != className) { return false; }
      switch (className) {
        case '[object String]': return a == String(b);
        case '[object Number]':
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          return +a == +b;
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') { return false; }
      length = stack.length;
      while (length--) { if (stack[length] == a) { return true; } }
      stack.push(a);
      size = 0;
      result = true;
      if (className == '[object Array]') {
        alength = a.length;
        blength = b.length;
        if (first) { 
          switch (type) {
          case '===': result = alength === blength; break;
          case '<==': result = alength <= blength; break;
          case '<<=': result = alength < blength; break;
          }
          size = alength;
          first = false;
        } else {
          result = alength === blength;
          size = alength;
        }
        if (result) {
          while (size--) {
            if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
          }
        }
      } else {
        if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
          return false;
        }
        for (key in a) {
          if (has(a, key)) {
            size++;
            if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
          }
        }
        if (result) {
          sizeB = 0;
          for (key in b) {
            if (has(b, key)) { ++sizeB; }
          }
          if (first) {
            if (type === '<<=') {
              result = size < sizeB;
            } else if (type === '<==') {
              result = size <= sizeB
            } else {
              result = size === sizeB;
            }
          } else {
            first = false;
            result = size === sizeB;
          }
        }
      }
      stack.pop();
      return result;
    }
  }
}).call(this);
